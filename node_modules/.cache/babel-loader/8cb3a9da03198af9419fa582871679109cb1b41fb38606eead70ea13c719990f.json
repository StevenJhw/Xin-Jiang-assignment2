{"ast":null,"code":"import React,{useState,useEffect}from'react';import Cell from'./Cell';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";const Grid=_ref=>{let{rows,cols,cellStates,handleCellClick}=_ref;const[grid,setGrid]=useState([[]]);const[livingCells,setLivingCells]=useState(0);const[cntCellDeadCum,setCellDeadCum]=useState([[]]);const[autoplay,setAutoplay]=useState(false);// 用于跟踪自动播放的状态变量\nconst[longerLastingMode,setLongerLastingMode]=useState(false);// 新增长寿模式状态\n// 切换自动播放的函数\nconst toggleAutoplay=()=>{setAutoplay(!autoplay);};// 切换长寿模式\nconst toggleLongerLastingMode=()=>{setLongerLastingMode(!longerLastingMode);};// 使用 useEffect 钩子来启动或停止自动播放\nuseEffect(()=>{let intervalId;if(autoplay){// 如果自动播放激活，则设置定时器来定期调用前进模拟的函数\nintervalId=setInterval(handleStepSimulation,100);}else{// 如果自动播放停止，则清除定时器\nclearInterval(intervalId);}// 返回清除定时器的函数，以确保在组件卸载时清除定时器\nreturn()=>clearInterval(intervalId);},[autoplay,grid]);// 添加所有依赖项\n// 初始化网格状态，创建空白的网格\nuseEffect(()=>{setGrid(initializeGrid());},[rows,cols]);// 更新网格状态，处理单元格点击事件\nconst updateCell=(row,col)=>{const newGrid=[...grid];newGrid[row][col]=!newGrid[row][col];// 切换单元格状态\nsetGrid(newGrid);setLivingCells(countLivingCells(newGrid));// 创建 newCumGrid 的副本\nconst newCumGrid=[...cntCellDeadCum];// 根据条件更新 newCumGrid 的值\nif(newGrid[row][col]===true){newCumGrid[row][col]=0;}else{newCumGrid[row][col]+=1;}setCellDeadCum(newCumGrid);};// 计算当前存活细胞数量\nconst countLivingCells=grid=>{let count=0;grid.forEach(row=>{row.forEach(cell=>{if(cell){count++;}});});return count;};// 修改初始化网格的函数以实现集群设置\nfunction initializeGrid(){const newGrid=Array.from({length:rows},()=>Array.from({length:cols},()=>false));// 确定集群的数量和位置\nconst numClusters=Math.floor(rows*cols*0.05);// 集群数量为网格大小的5%\nfor(let i=0;i<numClusters;i++){const clusterRow=Math.floor(Math.random()*rows);const clusterCol=Math.floor(Math.random()*cols);newGrid[clusterRow][clusterCol]=true;// 将集群中心设置为活细胞\n// 在集群周围生成更多的活细胞\nfor(let dRow=-2;dRow<=2;dRow++){for(let dCol=-2;dCol<=2;dCol++){const neighborRow=clusterRow+dRow;const neighborCol=clusterCol+dCol;if(neighborRow>=0&&neighborRow<rows&&neighborCol>=0&&neighborCol<cols&&Math.random()<0.05){newGrid[neighborRow][neighborCol]=true;}}}}setLivingCells(countLivingCells(newGrid));setCellDeadCum(Array.from({length:rows},()=>Array.from({length:cols},()=>1)));const newCntCellDeadCum=Array.from({length:rows},()=>Array.from({length:cols},()=>1));// 遍历 newGrid 的所有元素\nfor(let i=0;i<rows;i++){for(let j=0;j<cols;j++){// 如果 newGrid[i][j] 的值为真（即细胞存活），将相应位置的 newCntCellDeadCum 设置为0\nif(newGrid[i][j]===true){newCntCellDeadCum[i][j]=0;}}}// 设置新的 cntCellDeadCum 数组\nsetCellDeadCum(newCntCellDeadCum);return newGrid;}// 重置网格\nconst handleReset=()=>{const newGrid=initializeGrid();setGrid(newGrid);};// 进行单步模拟\nconst handleStepSimulation=()=>{const newGrid=[];for(let i=0;i<rows;i++){const newRow=[];for(let j=0;j<cols;j++){const neighbors=countAliveNeighbors(i,j);// 根据规则更新细胞状态\nif(grid[i][j]){if(neighbors<2||neighbors>3){newRow.push(false);// 规则 1 和 3：少于2个邻居或多于3个邻居，细胞死亡\n}else{newRow.push(true);// 规则 2：2 或 3 个邻居，细胞继续存活\n}}else{if(neighbors===3||longerLastingMode&&neighbors>=1){newRow.push(true);// 规则 4：3 个邻居，死细胞复活；或者长寿模式下有邻居，细胞继续存活\n}else{newRow.push(false);}}}newGrid.push(newRow);}setGrid(newGrid);setLivingCells(countLivingCells(newGrid));// newCumGrid heatmap\nconst newCumGrid=[...cntCellDeadCum];// 遍历原始数组\nfor(let i=0;i<rows;i++){for(let j=0;j<cols;j++){if(newGrid[i][j]===true){newCumGrid[i][j]=0;// 如果newGrid[i][j]为true，则将对应位置的newCumGrid设置为0\n}else{// 如果newGrid[i][j]为false，则将对应位置的cntCellDeadCum加1\nnewCumGrid[i][j]=cntCellDeadCum[i][j]+1;}}}setCellDeadCum(newCumGrid);};// 计算细胞周围的活细胞数量\nconst countAliveNeighbors=(row,col)=>{let count=0;for(let i=row-1;i<=row+1;i++){for(let j=col-1;j<=col+1;j++){if(i!==row||j!==col){// 检查边界条件以避免越界访问\nif(i>=0&&i<rows&&j>=0&&j<cols&&grid[i][j]){count++;}}}}return count;};return/*#__PURE__*/_jsxs(\"div\",{className:\"grid\",children:[grid.map((row,rowIndex)=>/*#__PURE__*/_jsx(\"div\",{className:\"grid-row\",children:row.map((cell,colIndex)=>/*#__PURE__*/_jsx(Cell,{alive:cell,cntCellDeadCum:cntCellDeadCum[rowIndex][colIndex]// 传递 cntCellDeadCum 的值给 Cell 组件\n,onClick:()=>{updateCell(rowIndex,colIndex);handleCellClick(rowIndex*cols+colIndex);}},colIndex))},rowIndex)),/*#__PURE__*/_jsxs(\"div\",{className:\"controls\",children:[/*#__PURE__*/_jsx(\"button\",{onClick:handleReset,children:\"Reset\"}),/*#__PURE__*/_jsx(\"button\",{onClick:handleStepSimulation,children:\"Next Step\"}),/*#__PURE__*/_jsx(\"button\",{onClick:toggleAutoplay,children:autoplay?'Stop':'Auto Start'}),/*#__PURE__*/_jsxs(\"div\",{children:[\" \",/*#__PURE__*/_jsx(\"button\",{onClick:toggleLongerLastingMode,children:longerLastingMode?'LongerLastingMode OFF':'LongerLastingMode ON'})]}),/*#__PURE__*/_jsxs(\"div\",{children:[\"Living Cells: \",livingCells]})]})]});};export default Grid;","map":{"version":3,"names":["React","useState","useEffect","Cell","jsx","_jsx","jsxs","_jsxs","Grid","_ref","rows","cols","cellStates","handleCellClick","grid","setGrid","livingCells","setLivingCells","cntCellDeadCum","setCellDeadCum","autoplay","setAutoplay","longerLastingMode","setLongerLastingMode","toggleAutoplay","toggleLongerLastingMode","intervalId","setInterval","handleStepSimulation","clearInterval","initializeGrid","updateCell","row","col","newGrid","countLivingCells","newCumGrid","count","forEach","cell","Array","from","length","numClusters","Math","floor","i","clusterRow","random","clusterCol","dRow","dCol","neighborRow","neighborCol","newCntCellDeadCum","j","handleReset","newRow","neighbors","countAliveNeighbors","push","className","children","map","rowIndex","colIndex","alive","onClick"],"sources":["/Users/Steven/Desktop/NEU/2024 Spring/5610 Web/Project/conways-game-of-life/src/Grid.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport Cell from './Cell';\n\nconst Grid = ({ rows, cols, cellStates, handleCellClick }) => {\n  const [grid, setGrid] = useState([[]]);\n  const [livingCells, setLivingCells] = useState(0);\n  const [cntCellDeadCum, setCellDeadCum] = useState([[]]); \n\n\n  const [autoplay, setAutoplay] = useState(false); // 用于跟踪自动播放的状态变量\n  const [longerLastingMode, setLongerLastingMode] = useState(false); // 新增长寿模式状态\n\n  // 切换自动播放的函数\n  const toggleAutoplay = () => {\n    setAutoplay(!autoplay);\n  };\n   // 切换长寿模式\n   const toggleLongerLastingMode = () => {\n    setLongerLastingMode(!longerLastingMode);\n  };\n\n  // 使用 useEffect 钩子来启动或停止自动播放\n  useEffect(() => {\n    let intervalId;\n    if (autoplay) {\n      // 如果自动播放激活，则设置定时器来定期调用前进模拟的函数\n      intervalId = setInterval(handleStepSimulation, 100);\n    } else {\n      // 如果自动播放停止，则清除定时器\n      clearInterval(intervalId);\n    }\n\n    // 返回清除定时器的函数，以确保在组件卸载时清除定时器\n    return () => clearInterval(intervalId);\n  }, [autoplay, grid]); // 添加所有依赖项\n\n\n  // 初始化网格状态，创建空白的网格\n  useEffect(() => {\n    setGrid(initializeGrid());\n  }, [rows, cols]);\n\n  // 更新网格状态，处理单元格点击事件\n  const updateCell = (row, col) => {\n    const newGrid = [...grid];\n    newGrid[row][col] = !newGrid[row][col]; // 切换单元格状态\n    setGrid(newGrid);\n    setLivingCells(countLivingCells(newGrid)); \n\n   // 创建 newCumGrid 的副本\n    const newCumGrid = [...cntCellDeadCum];\n\n    // 根据条件更新 newCumGrid 的值\n    if (newGrid[row][col] === true) {\n    newCumGrid[row][col] = 0;\n    } else {\n    newCumGrid[row][col] += 1;\n    }\n    setCellDeadCum(newCumGrid)\n\n  };\n\n  // 计算当前存活细胞数量\n  const countLivingCells = (grid) => {\n    let count = 0;\n    grid.forEach(row => {\n      row.forEach(cell => {\n        if (cell) {\n          count++;\n        }\n      });\n    });\n    return count;\n  };\n\n  // 修改初始化网格的函数以实现集群设置\nfunction initializeGrid() {\n  const newGrid = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => false)\n  );\n\n  // 确定集群的数量和位置\n  const numClusters = Math.floor(rows * cols * 0.05); // 集群数量为网格大小的5%\n  for (let i = 0; i < numClusters; i++) {\n    const clusterRow = Math.floor(Math.random() * rows);\n    const clusterCol = Math.floor(Math.random() * cols);\n    newGrid[clusterRow][clusterCol] = true; // 将集群中心设置为活细胞\n    // 在集群周围生成更多的活细胞\n    for (let dRow = -2; dRow <= 2; dRow++) {\n      for (let dCol = -2; dCol <= 2; dCol++) {\n        const neighborRow = clusterRow + dRow;\n        const neighborCol = clusterCol + dCol;\n        if (\n          neighborRow >= 0 &&\n          neighborRow < rows &&\n          neighborCol >= 0 &&\n          neighborCol < cols &&\n          Math.random() < 0.05\n        ) {\n          newGrid[neighborRow][neighborCol] = true;\n        }\n      }\n    }\n  }\n\n  setLivingCells(countLivingCells(newGrid));\n  setCellDeadCum(Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => 1)\n  ));\n\n  const newCntCellDeadCum = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => 1)\n  );\n  // 遍历 newGrid 的所有元素\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      // 如果 newGrid[i][j] 的值为真（即细胞存活），将相应位置的 newCntCellDeadCum 设置为0\n      if (newGrid[i][j] === true) {\n        newCntCellDeadCum[i][j] = 0;\n      }\n    }\n  }\n  // 设置新的 cntCellDeadCum 数组\n  setCellDeadCum(newCntCellDeadCum);\n\n  return newGrid;\n}\n\n\n  // 重置网格\n  const handleReset = () => {\n    const newGrid = initializeGrid();\n    setGrid(newGrid);\n  };\n// 进行单步模拟\nconst handleStepSimulation = () => {\n    const newGrid = [];\n  \n    for (let i = 0; i < rows; i++) {\n      const newRow = [];\n  \n      for (let j = 0; j < cols; j++) {\n        const neighbors = countAliveNeighbors(i, j);\n  \n        // 根据规则更新细胞状态\n        if (grid[i][j]) {\n          if (neighbors < 2 || neighbors > 3) {\n            newRow.push(false); // 规则 1 和 3：少于2个邻居或多于3个邻居，细胞死亡\n          } else {\n            newRow.push(true); // 规则 2：2 或 3 个邻居，细胞继续存活\n          }\n        } else {\n          if (neighbors === 3 || (longerLastingMode && neighbors >= 1)) {\n            newRow.push(true); // 规则 4：3 个邻居，死细胞复活；或者长寿模式下有邻居，细胞继续存活\n          } else {\n            newRow.push(false);\n          }\n        }\n      }\n  \n      newGrid.push(newRow);\n    }\n  \n    setGrid(newGrid);\n    setLivingCells(countLivingCells(newGrid));\n\n\n    // newCumGrid heatmap\n    const newCumGrid = [...cntCellDeadCum];\n    // 遍历原始数组\n    for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n        if (newGrid[i][j] === true) {\n        newCumGrid[i][j] = 0; // 如果newGrid[i][j]为true，则将对应位置的newCumGrid设置为0\n        } else {\n        // 如果newGrid[i][j]为false，则将对应位置的cntCellDeadCum加1\n        newCumGrid[i][j] = cntCellDeadCum[i][j] + 1;\n        }\n    }\n    }\n    setCellDeadCum(newCumGrid)\n  };\n  \n  // 计算细胞周围的活细胞数量\n  const countAliveNeighbors = (row, col) => {\n    let count = 0;\n  \n    for (let i = row - 1; i <= row + 1; i++) {\n      for (let j = col - 1; j <= col + 1; j++) {\n        if (i !== row || j !== col) {\n          // 检查边界条件以避免越界访问\n          if (i >= 0 && i < rows && j >= 0 && j < cols && grid[i][j]) {\n            count++;\n          }\n        }\n      }\n    }\n  \n    return count;\n  };\n  \n\n  return (\n    <div className=\"grid\">\n      {grid.map((row, rowIndex) => (\n        <div key={rowIndex} className=\"grid-row\">\n          {row.map((cell, colIndex) => (\n            <Cell\n              key={colIndex}\n              alive={cell}\n              cntCellDeadCum={cntCellDeadCum[rowIndex][colIndex]} // 传递 cntCellDeadCum 的值给 Cell 组件\n              onClick={() => {\n                updateCell(rowIndex, colIndex);\n                handleCellClick(rowIndex * cols + colIndex);\n              }}\n            />\n          ))}\n        </div>\n      ))}\n      <div className=\"controls\">\n        <button onClick={handleReset}>Reset</button>\n        <button onClick={handleStepSimulation}>Next Step</button> \n         <button onClick={toggleAutoplay}>\n          {autoplay ? 'Stop' : 'Auto Start'}\n        </button>\n        \n        <div> <button onClick={toggleLongerLastingMode}>\n          {longerLastingMode ? 'LongerLastingMode OFF' : 'LongerLastingMode ON'}\n        </button></div>\n        <div>Living Cells: {livingCells}</div>\n      </div>\n    </div>\n  );\n};\n\nexport default Grid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}